#!/usr/bin/env ruby

require "optparse"
require "optparse/time"
require "futureshop"

SUPPORTED_COMMANDS = %w[orders]

def main(argv)
  global_options = parse_global_options(argv)
  subcommand = argv.shift
  abort "Specify subcommand" unless subcommand
  abort "Unknown subcommand: #{subcommand}" unless SUPPORTED_COMMANDS.include?(subcommand)
  case subcommand
  when "orders"
    orders global_options, argv
  end
end

def parse_options(argv)
  options = {}
  OptionParser.new {|opt|
    yield opt
  }.order!(argv, into: options)
  options
end

def parse_global_options(argv)
  parse_options(argv) {|opt|
    opt.on "--verbose" do
      $VERBOSE = true
    end
  }
end

def orders(global_options, argv)
  options = {format: "json"}
  options.update(parse_options(argv) {|opt|
    opt.on "-f", "--format=FORMAT", ["json", "csv"]
    opt.on "--order-date-start=DATE", Time
    opt.on "--order-date-end=DATE", Time
  })
  Futureshop.orders(order_date_start: options[:"order-date-start"], order_date_end: options[:"order-date-end"], format: options["format"])
end

def client
  Futureshop::Client.new(
    shop_key: ENV["FUTURESHOP_SHOP_KEY"],
    client_id: ENV["FUTURESHOP_CLIENT_ID"],
    client_secret: ENV["FUTURESHOP_CLIENT_SECRET"],
    api_domain: ENV["FUTURESHOP_API_DOMAIN"]
  )
end

def aggregate_headers(obj, headers = [])
  obj.each_pair do |key, value|
    unless %w[buyerInfo addressInfo shippingInfo shipmentList productList].include? key
      headers << key
    end
    case value
    when Hash
      headers.concat aggregate_headers(value).collect {|header| "#{key}.#{header}"}
    when Array
      sample = value[0]
      if sample
        headers.concat aggregate_headers(sample).collect {|header| "#{key}.#{header}"}
      end
    end
  end
  headers
end

main ARGV
